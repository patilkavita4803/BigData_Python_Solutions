Python OOP Assignment
Q1. What is the purpose of Python's OOP?
OOPS in programming stands for Object Oriented Programming System. It is a programming paradigm or methodology, to design a program using classes and objects OOPS treats every entity as an object.

Object-oriented programming in Python is centered around objects. Any code written using OOPS is to solve our problem, but is represented in the form of Objects. We can create as many objects as we want, for a given class.

So what are objects? Objects are anything that has properties and some behaviours. The properties of objects are often referred to as variables of the object, and behaviours are referred to as the functions of the objects. Objects can be real-life or logical.

Suppose, a Pen is a real-life object. The property of a pen include: it's color, type(gel pen or ball pen). And, the behaviour of the pen may include that, it can write, draw etc.

Some Major Benefits of OOPS Include:
They reduce the redundancy of the code by writing clear and re-usable codes (using inheritance).
They are easier to visualize because they completely relate to real-world scenarios. For example, the concept of objects, inheritance, abstractions, relate very closely to real-world scenarios(we will discuss them further in this article).
Every object in oops represent a different part of the code and have their own logic and data to communicate with each other. So, there are no complications in the code.

Q2. Where does an inheritance search look for an attribute?
An inheritance search looks for an attribute first in the instance object, then in the class the instance was created from, then in all higher superclasses, progressing from left to right (by default). The search stops at the first place the attribute is found.

Q3. How do you distinguish between a class object and an instance object?
The basic concept of OOP is this: Class >> Object >> Instance.

The class = the blue print. The Object is an actual thing that is built based on the ‘blue print’ (like the house). An instance is a virtual copy (but not a real copy) of the object.

Classes are a kind of factory for creating multiple instances. Classes also support operator overloading methods, which instances inherit, and treat any functions nested in the class as methods for processing instances.

Q4. What makes the first argument in a class’s method function special?
The calling process is automatic while the receiving process is not (its explicit). This is the reason the first parameter of a function in class must be the object itself. Writing this parameter as self is merely a convention. It is not a keyword and has no special meaning in Python.

Q5. What is the purpose of the init method?
Python is an object-oriented language. This means that everything in python is an object.
Every time an object is created from a class, the __init__function is called. The __init__ method only allows the class to initialize the object's attributes. It is only used within classes.

Let’s say you are making a program which stores information about cars. You will create a class of name Car and then create objects of different cars. When creating a class object, we pass different things to it. In the case of cars, it will be company model, year of manufacture, etc. So, inside the class, we need a function that can assign all the arguments passed while creating the object to the newly created object. Or you might want to print something whenever a new car is added to your program.

There is a method called __init__() for this task. This method is called automatically whenever a new object of a class is created. This type of function is also known as the constructor function. A constructor function is a function that is called every time a new class object is created.
Constructors are used to initialize the data members of the class when an object is created. Python uses the __init__ method as a constructor to initialize the data members when an object is created for the class.
Q6. What is the process for creating a class instance?

Q7. What is the process for creating a class?
Like function definitions begin with the def keyword in Python, class definitions begin with a class keyword.
	
Following the keyword class, we have the class identifier(i.e. the name of the class we created) and then the : (colon) operator after the class name.

In the next indented lines(statement 1..n) are the members of the class. Also, the variables inside the class are known as attributes. The attributes can be accessed later on in the program using the dot(.) operator.

The syntax for creating a Class in Python is as follows:

class ClassName:
    # Statement 1
    # Statement 2
    .
    # Statement n
Let’s take a simple example of a class named Scaler.

class Sample:
    pass
Note: The keyword pass denotes an empty class. It is written just to avoid any errors in the console while running the above code.

Q8. How would you define the superclasses of a class?
The class from which a class inherits is called the parent or superclass. A class which inherits from a superclass is called a subclass, also called heir class or child class. Superclasses are sometimes called ancestors as well.
A superclass is the class from which many subclasses can be created.
The subclasses inherit the characteristics of a superclass. 
The superclass is also known as the parent class or base class. 
In the above example, Vehicle is the Superclass and its subclasses are Car,
Truck and Motorcycle.

Q9. What is the relationship between classes and modules?

The difference between a class and a module in python is that a class is used to define a blueprint for a given object, whereas a module is used to reuse a given piece of code inside another program.

A class can have its own instance, but a module cannot be instantiated. We use the ‘class’ keyword to define a class, whereas to use modules, we use the ‘import’ keyword. We can inherit a particular class and modify it using inheritance. But while using modules, it is simply a code containing variables, functions, and classes.

Modules are files present inside a package, whereas a class is used to encapsulate data and functions together inside the same unit.

Q10. How do you make instances and classes?
These are the variables that are defined inside the particular class and can be used by all the objects. These attributes can, later on, be called by using the class and attribute name with the dot(.) operator.

class Sample:
    Course1 = 'Python'
    Course2 = 'C++'
    Course3 = 'Java'
# Accessing the values of the attributes
print(Sample.Course1)
print(Sample.Course3)
# Accessing through object instantiation.
obj= Sample()
print(obj.Course2)

Here we have defined several attributes inside the Sample Class. Also, we have shown two ways of accessing the values of those attributes. One, by directly using the class name and the other by using an object(class instance). Assigning a class to a variable is known as object instantiation.

Note: If we change the value of the attribute using the class name(the first method in the above example), then it would change across all the instances of that class. While if we change the value of an attribute using class instance(object instantiation), it would only change the value of the attribute in that instance only.

Q11. Where and how should be class attributes created?
An attribute of class means these are the terms used for describing the properties or fields or data members or class members of the class. Attribute simply means the data member of an object. In Python, the class attribute is an attribute of the class that belongs to the class itself, which means it is the class’s attribute rather than an attribute of an instance of a class. The Python class attributes will be shared by all the instances where instance attributes are not shared between instances.

An attribute is a changeable property or any characteristics of any component or program, or class that can set to different values. For example: In general, the attribute for humans can be hair, the color of the face, etc.
class classwithattribute:
count = 0
print count
def increment(self):
classwithattribute.count += 1
c1 = classwithattribute()
c1.increment()
print c1.count
c2 = classwithattribute()
c2.increment()
print c2.count
print classwithattribute.count


Q12. Where and how are instance attributes created?
Instance attributes are attributes or properties attached to an instance of a class. Instance attributes are defined in the constructor.

class Student:
    def __init__(self, name, age): 
        self.name = name
        self.age = age
#Now, you can specify the values while creating an instance, as shown below.

std = Student('Bill',25)
std.name
'Bill'
std.age
25
std.name = 'Steve'
std.age = 45
std.name
'Steve'
std.age
45

Q13. What does the term "self" in a Python class mean?

In object-oriented programming, whenever we define methods for a class, we use self as the first parameter in each case. Let's look at the definition of a class called Cat.

class Cat:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def info(self):
        print(f"I am a cat. My name is {self.name}. I am {self.age} years old.")

    def make_sound(self):
        print("Meow")
In this case all the methods, including __init__, have the first parameter as self.

We know that class is a blueprint for the objects. This blueprint can be used to create multiple numbers of objects. Let's create two different objects from the above class.

cat1 = Cat('Andy', 2)
cat2 = Cat('Phoebe', 3)
The self keyword is used to represent an instance (object) of the given class. In this case, the two Cat objects cat1 and cat2 have their own name and age attributes. If there was no self argument, the same class couldn't hold the information for both these objects.

However, since the class is just a blueprint, self allows access to the attributes and methods of each object in python. This allows each object to have its own attributes and methods. Thus, even long before creating these objects, we reference the objects as self while defining the class.


Q14. How does a Python class handle operator overloading?

Python operators work for built-in classes. But the same operator behaves differently with different types. For example, the + operator will perform arithmetic addition on two numbers, merge two lists, or concatenate two strings.

This feature in Python that allows the same operator to have different meaning according to the context is called operator overloading.

If you’ve used the + or * operator on a str object in Python, you must have noticed its different behavior when compared to int or float objects:

>>> # Adds the two numbers
>>> 1 + 2
3

>>> # Concatenates the two strings
>>> 'Real' + 'Python'
'RealPython'


>>> # Gives the product
>>> 3 * 2
6

>>> # Repeats the string
>>> 'Python' * 3
'PythonPythonPython'
You might have wondered how the same built-in operator or function shows different behavior for objects of different classes. This is called operator overloading or function overloading respectively. 

Q15. When do you consider allowing operator overloading of your classes?
The operator overloading in Python means provide extended meaning beyond their predefined operational meaning. Such as, we use the "+" operator for adding two integers as well as joining two strings or merging two lists. We can achieve this as the "+" operator is overloaded by the "int" class and "str" class.

Q16. What is the most popular form of operator overloading?
Operator overloading is the process of using an operator in different ways depending on the operands. You can change the way an operator in Python works on different data-types.

A very popular and convenient example is the Addition (+) operator.

Just think how the ‘+’ operator operates on two numbers and the same operator operates on two strings. It performs “Addition” on numbers whereas it performs “Concatenation” on strings.

Operators in Python work for built-in classes, like int, str, list, etc. But you can extend their operability such that they work on objects of user-defined classes too.

Q17. What are the two most important concepts to grasp in order to comprehend Python OOP code?
Both inheritance and polymorphism are fundamental concepts of object oriented programming. These concepts help us to create code that can be extended and easily maintainable.

Q18. Describe three applications for exception processing.








Q19. What happens if you don't do something extra to treat an exception?

When an exception occurred, if you don’t handle it, the program terminates abruptly and the code past the line that caused the exception will not get executed.

Example
Generally, an array is of fixed size and each element is accessed using the indices. For example, we have created an array with size 7. Then the valid expressions to access the elements of this array will be a[0] to a[6] (length-1).

Whenever, you used an –ve value or, the value greater than or equal to the size of the array, then the ArrayIndexOutOfBoundsException is thrown.

For Example, if you execute the following code, it displays the elements in the array asks you to give the index to select an element. Since the size of the array is 7, the valid index will be 0 to 6.

Q20. What are your options for recovering from an exception in your script?

Handling an exception
If you have some suspicious code that may raise an exception, you can defend your program by placing the suspicious code in a try: block. After the try: block, include an except: statement, followed by a block of code which handles the problem as elegantly as possible.

Syntax
Here is simple syntax of try....except...else blocks −

This example opens a file, writes content in the, file and comes out gracefully because there is no problem at all −

 Live Demo
#!/usr/bin/python

try:
   fh = open("testfile", "w")
   fh.write("This is my test file for exception handling!!")
except IOError:
   print "Error: can\'t find file or read data"
else:
   print "Written content in the file successfully"
   fh.close()
   
   Here are few important points about the above-mentioned syntax −

A single try statement can have multiple except statements. This is useful when the try block contains statements that may throw different types of exceptions.

You can also provide a generic except clause, which handles any exception.

After the except clause(s), you can include an else-clause. The code in the else-block executes if the code in the try: block does not raise an exception.

The else-block is a good place for code that does not need the try: block's protection.

Q21. Describe two methods for triggering exceptions in your script.




Q22. Identify two methods for specifying actions to be executed at termination time, regardless of whether or not an exception exists.



Q23. What is the purpose of the try statement?
Try Except in Python allows you to catch errors and, instead of dying, do something more reasonable.
The Try method is used in Error and Exception Handling. There are two kinds of errors :

Syntax Error: It is also known as Parsing Error. This occurs when the Python parser is unable to understand a line of code.

Exception Error: These errors are detected during execution.

Now, in these situations, we need to handle these errors within our code in Python. That is where try-except in python comes handy.
How Does Try() Work?
The different steps involved in the working of try are:

The try clause is executed between the try and except clause.
If there is no exception, then only the try clause will run and except clause is finished.
The try clause will be skipped and except clause will run if any exception occurs.
In case of any exception, if the except clause within the code doesn’t handle it, it is passed on to the outer try statements. The execution is stopped if the exception left unhandled.
A try statement can have more than one except clause.
 

Python Exceptions Example
In the first example, there is no exception, so the try clause will run:

def divide(x, y):
try:
result = x // y
print("The answer is :", result)
except ZeroDivisionError:
print("Sorry ! Cannot divide by zero ")
divide(10, 5)
Output:The answer is : 2

Q24. What are the two most popular try statement variations?
try except and ELSE!
Sometimes you might have a use case where you want to run some specific code only when there are no exceptions. For such scenarios, the else keyword can be used with the try block. Note that this else keyword and its block are optional.
When an exception is not raised, it flows into the optional else block.

try:
 b  = 10
 c = 2
 a = b/c
 print(a)
except:
 print('Exception raised')
else:
  print('no exceptions raised')
Output:

5.0 
no exceptions raised
In the above code, As both the inputs are greater than 0 which is not a risk to DivideByZeroException, hence try block won’t raise any exception and hence ‘except’ block won’t be triggered. And only when the control doesn’t flow to the except block, it flows to the else block. Further handling can be done inside this else block if there is something you want to do.

Example:

When an exception is raised, control flows into the except block and not the else block.

try:
   b  = 10
   c = 0
   a = b/c
   print(a)
except Exception as e:
   print('Exception raised:', e)
else:
   print('no exceptions raised')
Output:

Exception raised: division by zero
In the above code, As both the ‘b’ input is 0 which is a risk to DivideByZeroException, hence the ‘try’ block will raise an exception, and hence the ‘except’ block will be triggered. And now as there is an exception raised, the control flows to the except block and not to the else block.

Q25. What is the purpose of the raise statement?
Raising Exceptions in Python
In Python programming, exceptions are raised when errors occur at runtime. We can also manually raise exceptions using the raise keyword.

We can optionally pass values to the exception to clarify why that exception was raised.

The raise keyword is used to raise an exception.
You can define what kind of error to raise, and the text to print to the user.

Raise a TypeError if x is not an integer:

x = "hello"

if not type(x) is int:
  raise TypeError("Only integers are allowed")
  
Q26. What does the assert statement do, and what other statement is it like?

Q27. What is the purpose of the with/as argument, and what other statement is it like?

Q28. What are *args, **kwargs?

Q29. How can I pass optional or keyword parameters from one function to another?

Q30. What are Lambda Functions?

Q31. Explain Inheritance in Python with an example?

Q32. Suppose class C inherits from classes A and B as class C(A,B).Classes A and B both have their own versions of method func(). If we call func() from an object of class C, which version gets invoked?

Q33. Which methods/functions do we use to determine the type of instance and inheritance?

Q34.Explain the use of the 'nonlocal' keyword in Python.

Q35. What is the global keyword?